import{_ as e,o as t,c as a,R as p}from"./chunks/framework.BMSw91m9.js";const v=JSON.parse('{"title":"Vue2和Vue3的区别","description":"","frontmatter":{},"headers":[],"relativePath":"快速开发/Vue3面试题.md","filePath":"快速开发/Vue3面试题.md"}'),s={name:"快速开发/Vue3面试题.md"},o=p('<h1 id="vue2和vue3的区别" tabindex="-1">Vue2和Vue3的区别 <a class="header-anchor" href="#vue2和vue3的区别" aria-label="Permalink to &quot;Vue2和Vue3的区别&quot;">​</a></h1><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>1.Vue2是选项是写法 而 Vue3 是组合式写法</p><p>2.Vue2和Vue3 生命周期不一样 Vue3大多数生命周期前面多了个On</p><p>3.数据双向绑定原理不同:Vue2利用ES5的一个APIObject.defineProperty()对数据进行劫持，Vue3使用了ES6的Proxy API对数据代理。</p><p>4.定义变量和方法不同: Vue2在data中定义变量，在methods中创建方法 Vue3使用一个新的Setup方法</p><p>5.父子之间传参不同 : Vue2组件通信 prop $emit 父传子需要触发监听传递参数 Vue3使用Setup()中的第二个参数content对象中有emit，只需要在Setup()接收第二个参数中使用分解对象法取出emit就可以在Setup方法中随意使用了。</p></div><h1 id="vue3-常用的api" tabindex="-1">Vue3 常用的APi <a class="header-anchor" href="#vue3-常用的api" aria-label="Permalink to &quot;Vue3 常用的APi&quot;">​</a></h1><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>1.Setup： 组件中所用到的：数据、方法等等，均要配置在setup中</p><p>2.Ref函数： 创建一个包含响应式数据的引用对象（reference对象，简称ref对象）</p><p>3.reactive函数： 定义一个对象类型的响应式数据（基本类型不要用，要用ref函数） reactive定义的响应式数据是“深层次的”</p><p>4.computed函数 只要该计算属性依赖的响应式变量发生变化，它就会自动更新。</p><p>5.watch函数</p><p>6.vue3的生命周期</p><p>7.toRef 和 toRefs</p></div><h1 id="vue3-setup函数里面有两个参数是干嘛的" tabindex="-1">Vue3 Setup函数里面有两个参数是干嘛的 <a class="header-anchor" href="#vue3-setup函数里面有两个参数是干嘛的" aria-label="Permalink to &quot;Vue3 Setup函数里面有两个参数是干嘛的&quot;">​</a></h1><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>setup函数两个参数分别是 Props 和 Context包含（ attrs、emit、slots、expose）</p><p>Props: 值为对象，包含：组件外部传递过来。切组件内部声明接收了的属性</p><p>Context : attrs：值为对象，包含组件外部传递过来，但没有在props配置中声明的属性。相当于this.$attrs</p><p>slots：收到的插槽内容，相当于this.$slots</p><p>emit：分发自定义事件的函数，相当于this.$emit</p></div><h1 id="vue3-setup执行在哪个生命周期前面" tabindex="-1">Vue3 Setup执行在哪个生命周期前面 <a class="header-anchor" href="#vue3-setup执行在哪个生命周期前面" aria-label="Permalink to &quot;Vue3 Setup执行在哪个生命周期前面&quot;">​</a></h1><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>setup() : 开始创建组件之前，在 BeforeCreate（创建前） 和 Created（创建后） 之前执行，创建的是 Data 和 Method</p></div><h1 id="ref函数和reactive函数的区别" tabindex="-1">ref函数和reactive函数的区别 <a class="header-anchor" href="#ref函数和reactive函数的区别" aria-label="Permalink to &quot;ref函数和reactive函数的区别&quot;">​</a></h1><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>ref： ref是定义简单类型 和单一的对象</p><p>reactive：定义复杂的类型 reactive解构赋值容易丢失响应式</p></div>',10),u=[o];function i(r,c,l,d,n,h){return t(),a("div",null,u)}const V=e(s,[["render",i]]);export{v as __pageData,V as default};
